From 997b1468289e4cfc64f67eb35bf0d4ef3ed341cb Fri, 16 Dec 2016 15:10:42 +0100
From: Yann R. <yradenac@free.fr>
Date: Tue, 29 Nov 2016 10:41:19 +0100
Subject: [PATCH] [tracker] Use Xing mp3 header when available. Fixes JB#36891

diff --git a/src/tracker-extract/tracker-extract-mp3.c b/src/tracker-extract/tracker-extract-mp3.c
index ef30342..cf3b92e 100644
--- a/src/tracker-extract/tracker-extract-mp3.c
+++ b/src/tracker-extract/tracker-extract-mp3.c
@@ -147,6 +147,12 @@
 } id3v24frame;
 
 typedef struct {
+	guint nb_frames;
+	guint nb_bytes;
+	/* ignoring other fields (TOC entries and quality indicator) */
+} xingtag;
+
+typedef struct {
 	size_t size;
 	size_t id3v2_size;
 
@@ -180,6 +186,7 @@
 	id3v2tag id3v22;
 	id3v2tag id3v23;
 	id3v2tag id3v24;
+	xingtag xing;
 } MP3Data;
 
 enum {
@@ -398,15 +405,18 @@
 	"Synthpop"
 };
 
-static const guint sync_mask = 0xE0FF;
-static const guint mpeg_ver_mask = 0x1800;
-static const guint mpeg_layer_mask = 0x600;
-static const guint bitrate_mask = 0xF00000;
-static const guint freq_mask = 0xC0000;
-static const guint ch_mask = 0xC0000000;
-static const guint pad_mask = 0x20000;
+typedef struct {
+	gint version;
+	gint layer;
+	gboolean has_crc;
+	gint bitrate;
+	gint sample_rate;
+	gboolean is_padded;
+	gint n_channels;
+	size_t size;
+} mpeg_frame_info;
 
-static gint bitrate_table[16][6] = {
+static const gint bitrate_table[16][6] = {
 	{   0,   0,   0,   0,   0,   0 },
 	{  32,  32,  32,  32,   8,   8 },
 	{  64,  48,  40,  48,  16,  16 },
@@ -425,15 +435,28 @@
 	{  -1,  -1,  -1,  -1,  -1,  -1 }
 };
 
-static gint freq_table[4][3] = {
+static const gint freq_table[4][3] = {
 	{ 44100, 22050, 11025 },
 	{ 48000, 24000, 12000 },
 	{ 32000, 16000,  8000 },
 	{    -1,     -1,   -1 }
 };
 
-static gint spf_table[6] = {
+static const gint spf_table[6] = {
 	48, 144, 144, 48, 144,  72
+};
+
+/* Samples per MPEG audio frame table[layer_version][mpeg_version] */
+static const guint samples_per_frame_table[3][3] = {
+	{  384,  384,  384 },
+	{ 1152, 1152, 1152 },
+	{ 1152,  576,  576 },
+};
+
+/* Layer III side information size in bytes table[stereo/mono][mpeg_version] */
+static const guint side_info_size_table[2][3] = {
+	{ 17,  9,  9 },  /* mono */
+	{ 32, 17, 17 },  /* stereo */
 };
 
 #ifndef HAVE_STRNLEN
@@ -900,6 +923,246 @@
 	return TRUE;
 }
 
+static inline gboolean
+is_mpeg_frame_header (guint header)
+{
+	const guint sync_mask = 0xE0FF;
+	return (header & sync_mask) == sync_mask;
+}
+
+static gboolean
+get_frame_info (guint header, mpeg_frame_info *info)
+{
+	const guint mpeg_ver_mask = 0x1800;
+	const guint mpeg_layer_mask = 0x600;
+	const guint bitrate_mask = 0xF00000;
+	const guint freq_mask = 0xC0000;
+	const guint ch_mask = 0xC0000000;
+	const guint pad_mask = 0x20000;
+
+	gint spfp8;
+	gint idx_num;
+	guint padsize;
+	gint freq;
+	guint pad;
+
+	if (!(is_mpeg_frame_header(header))) {
+		g_debug("get_frame_info: not an mpeg audio frame 0x%x", header);
+	    return FALSE;
+	}
+
+	switch (header & mpeg_ver_mask) {
+	case 0x1000:
+		info->version = MPEG_V2;
+		break;
+	case 0x1800:
+		info->version = MPEG_V1;
+		break;
+	case 0:
+		info->version = MPEG_V25;
+		break;
+	default:
+		/* unknown version */
+		return FALSE;
+	}
+
+	switch (header & mpeg_layer_mask) {
+	case 0x400:
+		info->layer = LAYER_2;
+		padsize = 1;
+		break;
+	case 0x200:
+		info->layer = LAYER_3;
+		padsize = 1;
+		break;
+	case 0x600:
+		info->layer = LAYER_1;
+		padsize = 4;
+		break;
+	default:
+		/* unknown layer */
+		return FALSE;
+	}
+
+	if (info->version < 3) {
+		idx_num = (info->version - 1) * 3 + info->layer - 1;
+	} else {
+		idx_num = 2 + info->layer;
+	}
+
+	info->bitrate = 1000 * bitrate_table[(header & bitrate_mask) >> 20][idx_num];
+
+	freq = (header & freq_mask) >> 18;
+	info->sample_rate = freq_table[freq][info->version - 1];
+
+	pad = padsize * ((header & pad_mask) >> 17);
+	spfp8 = spf_table[idx_num];
+	info->size = spfp8 * info->bitrate / info->sample_rate + pad;
+
+	info->n_channels = ((header & ch_mask) == ch_mask) ? 1 : 2;
+
+	return TRUE;
+}
+
+/*
+ * For the Xing frame format, see
+ * http://www.codeproject.com/Articles/8295/MPEG-Audio-Frame-Header#VBRHeaders
+ * http://gabriel.mp3-tech.org/mp3infotag.html
+*/
+static gboolean
+parse_xing (const gchar *data, size_t size, size_t offset, MP3Data *filedata, mpeg_frame_info *finfo)
+{
+	size_t pos;
+	guint flags;
+	gboolean has_nb_frames;
+	guint nb_frames;
+	gboolean has_nb_bytes;
+	guint nb_bytes;
+	guint header;
+
+	pos = offset;
+	memcpy (&header, &data[pos], sizeof (header));
+	if (!get_frame_info(header, finfo)) {
+		return FALSE;
+	}
+	pos += 4; /* skip audio frame header */
+	pos += side_info_size_table[finfo->n_channels - 1][finfo->version - 1];
+
+	if (((data[pos] != 'X') || (data[pos+1] != 'i') || (data[pos+2] != 'n') || (data[pos+3] != 'g'))
+		&& ((data[pos] != 'I') || (data[pos+1] != 'n') || (data[pos+2] != 'f') || (data[pos+3] != 'o')))
+	{
+		/* First audio frame is not a Xing frame */
+		return FALSE;
+	}
+	pos += 4; /* skip "Xing" or "Info" */
+
+	flags = (((data[pos] & 0xFF) << 24) |
+			 ((data[pos+1] & 0xFF) << 16) |
+			 ((data[pos+2] & 0xFF) << 8) |
+			 ((data[pos+3] & 0xFF) << 0));
+	pos += 4; /* skip flags */
+
+	has_nb_frames = flags & 0x0001;
+	if (has_nb_frames) {
+		nb_frames = (((data[pos] & 0xFF) << 24) |
+					 ((data[pos+1] & 0xFF) << 16) |
+					 ((data[pos+2] & 0xFF) << 8) |
+					 ((data[pos+3] & 0xFF) << 0));
+		filedata->xing.nb_frames = nb_frames;
+		pos += 4; /* skip nb_frames */
+		g_debug("[xing] found number of frames = %d", nb_frames);
+	}
+
+	has_nb_bytes = flags & 0x0002;
+	if (has_nb_bytes) {
+		nb_bytes = (((data[pos] & 0xFF) << 24) |
+					((data[pos+1] & 0xFF) << 16) |
+					((data[pos+2] & 0xFF) << 8) |
+					((data[pos+3] & 0xFF) << 0));
+		filedata->xing.nb_bytes = nb_bytes;
+		pos += 4; /* skip nb_bytes */
+		g_debug("[xing] found number of bytes = %d", nb_bytes);
+	}
+
+	/* ignoring the optional 100 bytes TOC entries */
+	/* ignoring the optional 4 bytes quality indicator */
+
+	return has_nb_frames; /* && has_nb_bytes */
+}
+
+static gboolean
+get_duration (const gchar *data, size_t size, size_t offset,
+			  size_t *duration, MP3Data *filedata,
+			  mpeg_frame_info *finfo, guint *avg_bps)
+{
+	guint header;
+	size_t pos = offset;
+	guint frames;
+	guint samples_per_frame;
+	gboolean has_xing;
+	guint total_bitrate;
+
+	memcpy (&header, &data[pos], sizeof (header));
+	if (!(is_mpeg_frame_header(header))) {
+	    return FALSE;
+	}
+
+	has_xing = parse_xing (data, size, offset, filedata, finfo);
+	if (has_xing) {
+		samples_per_frame = samples_per_frame_table[finfo->layer - 1][finfo->version - 1];
+		*duration = filedata->xing.nb_frames * samples_per_frame / finfo->sample_rate;
+		if (filedata->xing.nb_bytes > 0) {
+			*avg_bps = filedata->xing.nb_bytes / *duration;
+		} else {
+			*avg_bps = (filedata->size - filedata->id3v2_size) / *duration;
+		}
+		return TRUE;
+	}
+
+	/* No Xing frame.
+	 * So scan some/all audio frames to compute/estimate the total duration.
+	 */
+
+	g_debug("No Xing, try to estimate duration...");
+
+	frames = 0;
+	total_bitrate = 0;
+	*duration = 0;
+	while (frames < MAX_FRAMES_SCAN  /* Optimization */
+	       && pos + sizeof(header) < size  /* EOF */
+	      ) {
+
+		memcpy (&header, &data[pos], sizeof (header));
+
+		if (!(is_mpeg_frame_header(header))) {
+			/* we may have reached an id3v1 tag, else the mp3 is corrupted */
+			if (pos + 2 < size &&
+			    data[pos] == 'T' &&
+			    data[pos + 1] == 'A' &&
+			    data[pos + 2] == 'G') {
+				break;
+			}
+		    return FALSE;
+		}
+		if (!get_frame_info(header, finfo)) {
+			return FALSE;
+		}
+
+		/* Skip frame headers with bitrate index '0000' (free) or '1111' (bad) */
+		if (finfo->bitrate <= 0) {
+			return FALSE;
+		}
+
+		/* Skip frame headers with frequency index '11' (reserved) */
+		if (finfo->sample_rate <= 0) {
+			return FALSE;
+		}
+
+		/* dividing by 1000 to postpone integer overflow in case of large file */
+		total_bitrate += finfo->bitrate / 1000;
+		samples_per_frame = samples_per_frame_table[finfo->layer - 1][finfo->version - 1];
+		*duration += (samples_per_frame * 1000) / finfo->sample_rate; /* milliseconds */
+		frames++;
+		pos += finfo->size;
+	}
+
+	if (frames < 2) {
+		/* not enough frames, and avoiding divisions by zero below. */
+		return FALSE;
+	}
+
+	*avg_bps = total_bitrate * 1000 / frames;
+
+	if (pos < size || size < filedata->size - filedata->id3v2_size) {
+		/* Whole file has not be scanned, adding an estimated remaining time. */
+		*duration = (int64_t)(filedata->size - filedata->id3v2_size) * 8 * 1000 / *avg_bps;
+	}
+
+	*duration /= 1000; /* milliseconds to seconds */
+
+	return TRUE;
+}
+
 /*
  * For the MP3 frame header description, see
  * http://www.mp3-tech.org/programmer/frame_header.html
@@ -913,142 +1176,28 @@
                   MP3Data              *filedata)
 {
 	const gchar *dlna_profile, *dlna_mimetype;
-	guint header;
-	gchar mpeg_ver = 0;
-	gchar layer_ver = 0;
-	gint spfp8 = 0;
-	guint padsize = 0;
-	gint idx_num = 0;
-	gint bitrate = 0;
-	guint avg_bps = 0;
-	gint vbr_flag = 0;
-	guint length = 0;
-	gint sample_rate = 0;
-	guint frame_size;
-	guint frames = 0;
-	size_t pos = 0;
-	gint n_channels;
+	size_t length;
+	mpeg_frame_info finfo;
+	gboolean got_length;
+	guint avg_bps;
 
-	pos = seek_pos;
-
-	memcpy (&header, &data[pos], sizeof (header));
-
-	switch (header & mpeg_ver_mask) {
-	case 0x1000:
-		mpeg_ver = MPEG_V2;
-		break;
-	case 0x1800:
-		mpeg_ver = MPEG_V1;
-		break;
-	case 0:
-		mpeg_ver = MPEG_V25;
-		break;
-	default:
-		/* unknown version */
+	got_length = get_duration(data, size, seek_pos, &length, filedata, &finfo, &avg_bps);
+	if (!got_length) {
 		return FALSE;
 	}
-
-	switch (header & mpeg_layer_mask) {
-	case 0x400:
-		layer_ver = LAYER_2;
-		padsize = 1;
-		break;
-	case 0x200:
-		layer_ver = LAYER_3;
-		padsize = 1;
-		break;
-	case 0x600:
-		layer_ver = LAYER_1;
-		padsize = 4;
-		break;
-	default:
-		/* unknown layer */
-		return FALSE;
-	}
-
-	if (mpeg_ver < 3) {
-		idx_num = (mpeg_ver - 1) * 3 + layer_ver - 1;
-	} else {
-		idx_num = 2 + layer_ver;
-	}
-
-	spfp8 = spf_table[idx_num];
 
 	/* We assume mpeg version, layer and channels are constant in frames */
-	do {
-		frames++;
-
-		bitrate = 1000 * bitrate_table[(header & bitrate_mask) >> 20][idx_num];
-
-		/* Skip frame headers with bitrate index '0000' (free) or '1111' (bad) */
-		if (bitrate <= 0) {
-			frames--;
-			return FALSE;
-		}
-
-		sample_rate = freq_table[(header & freq_mask) >> 18][mpeg_ver - 1];
-
-		/* Skip frame headers with frequency index '11' (reserved) */
-		if (sample_rate <= 0) {
-			frames--;
-			return FALSE;
-		}
-
-		frame_size = spfp8 * bitrate / sample_rate + padsize*((header & pad_mask) >> 17);
-		avg_bps += bitrate / 1000;
-
-		pos += frame_size;
-
-		if (frames > MAX_FRAMES_SCAN) {
-			/* Optimization */
-			break;
-		}
-
-		if (avg_bps / frames != bitrate / 1000) {
-			vbr_flag = 1;
-		}
-
-		if (pos + sizeof (header) > size) {
-			/* EOF */
-			break;
-		}
-
-		if ((!vbr_flag) && (frames > VBR_THRESHOLD)) {
-			break;
-		}
-
-		memcpy(&header, &data[pos], sizeof (header));
-	} while ((header & sync_mask) == sync_mask);
-
-	/* At least 2 frames to check the right position */
-	if (frames < 2) {
-		/* No valid frames */
-		return FALSE;
-	}
 
 	tracker_resource_set_string (resource, "nfo:codec", "MPEG");
 
-	n_channels = ((header & ch_mask) == ch_mask) ? 1 : 2;
-
-	tracker_resource_set_int (resource, "nfo:channels", n_channels);
-
-	avg_bps /= frames;
-
-	if ((!vbr_flag && frames > VBR_THRESHOLD) || (frames > MAX_FRAMES_SCAN)) {
-		/* If not all frames scanned
-		 * Note that bitrate is always > 0, checked before */
-		length = (filedata->size - filedata->id3v2_size) / (avg_bps ? avg_bps : bitrate) / 125;
-	} else {
-		/* Note that sample_rate is always > 0, checked before */
-		length = spfp8 * 8 * frames / sample_rate;
-	}
+	tracker_resource_set_int (resource, "nfo:channels", finfo.n_channels);
 
 	tracker_resource_set_int64 (resource, "nfo:duration", length);
-	tracker_resource_set_int64 (resource, "nfo:sampleRate", sample_rate);
-	tracker_resource_set_int64 (resource, "nfo:averageBitrate", avg_bps*1000);
+	tracker_resource_set_int64 (resource, "nfo:sampleRate", finfo.sample_rate);
+	tracker_resource_set_int64 (resource, "nfo:averageBitrate", avg_bps);
 
-	if (guess_dlna_profile (bitrate, sample_rate,
-	                        mpeg_ver, layer_ver, n_channels,
+	if (guess_dlna_profile (finfo.bitrate, finfo.sample_rate,
+	                        finfo.version, finfo.layer, finfo.n_channels,
 	                        &dlna_profile, &dlna_mimetype)) {
 		tracker_resource_set_string (resource, "nmm:dlnaProfile", dlna_profile);
 		tracker_resource_set_string (resource, "nmm:dlnaMime", dlna_mimetype);
@@ -1077,8 +1226,7 @@
 
 		memcpy (&header, &data[pos], sizeof (header));
 
-		if ((header & sync_mask) == sync_mask) {
-			/* Found header sync */
+		if (is_mpeg_frame_header(header)) {
 			if (mp3_parse_header (data, size, pos, uri, resource, filedata)) {
 				return TRUE;
 			}
